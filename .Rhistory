library(coda)
# Configurer les dimensions du dispositif graphique pour les 3 premiers graphiques
par(ask = FALSE, mfrow = c(3, 1), mar = c(1, 1, 3, 3)) # Configure la disposition des graphiques dans une matrice 3x1 et les marges
# Tracer les 3 premiers graphiques des chaînes de Markov
plot(mcmc(resultat_chain[,1:3]))
# Ajouter des titres personnalisés pour les 3 premiers graphiques
mtext(expression("Graphiques pour " * alpha[0]), side = 3, line = 23)
mtext(expression("Graphiques pour " * alpha[1]), side = 3, line = 11.5)
mtext(expression("Graphiques pour " * alpha[12]), side = 3, line = 0.5)
# Configurer les dimensions du dispositif graphique pour les 2 derniers graphiques
par(mfrow = c(2, 1)) # Configure la disposition des graphiques dans une matrice 2x1
# Tracer les 2 derniers graphiques des chaînes de Markov
plot(mcmc(resultat_chain)[,4:5])
# Ajouter des titres personnalisés pour les 2 derniers graphiques
mtext(expression("Graphiques pour " * alpha[2]), side = 3, line = 12)
mtext("Titre du Graphique 5", side = 3, line = 2)
library(coda)
# Configurer les dimensions du dispositif graphique pour les 3 premiers graphiques
par(ask = FALSE, mfrow = c(3, 1), mar = c(1, 1, 3, 3)) # Configure la disposition des graphiques dans une matrice 3x1 et les marges
# Tracer les 3 premiers graphiques des chaînes de Markov
plot(mcmc(resultat_chain[,1:3]))
# Ajouter des titres personnalisés pour les 3 premiers graphiques
mtext(expression("Graphiques pour " * alpha[0]), side = 3, line = 23)
mtext(expression("Graphiques pour " * alpha[1]), side = 3, line = 11.5)
mtext(expression("Graphiques pour " * alpha[12]), side = 3, line = 0.5)
# Configurer les dimensions du dispositif graphique pour les 2 derniers graphiques
par(mfrow = c(2, 1)) # Configure la disposition des graphiques dans une matrice 2x1
# Tracer les 2 derniers graphiques des chaînes de Markov
plot(mcmc(resultat_chain)[,4:5])
# Ajouter des titres personnalisés pour les 2 derniers graphiques
mtext(expression("Graphiques pour " * alpha[2]), side = 3, line = 12)
mtext("Titre du Graphique 5", side = 3, line = 1)
library(coda)
# Configurer les dimensions du dispositif graphique pour les 3 premiers graphiques
par(ask = FALSE, mfrow = c(3, 1), mar = c(1, 1, 3, 3)) # Configure la disposition des graphiques dans une matrice 3x1 et les marges
# Tracer les 3 premiers graphiques des chaînes de Markov
plot(mcmc(resultat_chain[,1:3]))
# Ajouter des titres personnalisés pour les 3 premiers graphiques
mtext(expression("Graphiques pour " * alpha[0]), side = 3, line = 23)
mtext(expression("Graphiques pour " * alpha[1]), side = 3, line = 11.5)
mtext(expression("Graphiques pour " * alpha[12]), side = 3, line = 0.5)
# Configurer les dimensions du dispositif graphique pour les 2 derniers graphiques
par(mfrow = c(2, 1)) # Configure la disposition des graphiques dans une matrice 2x1
# Tracer les 2 derniers graphiques des chaînes de Markov
plot(mcmc(resultat_chain)[,4:5])
# Ajouter des titres personnalisés pour les 2 derniers graphiques
mtext(expression("Graphiques pour " * alpha[2]), side = 3, line = 12)
mtext(expression("Graphiques pour " * sigma), side = 3, line = 1)
library(coda)
par(ask = FALSE, mfrow = c(3, 1), mar = c(1, 1, 3, 3)) # Configure la disposition des graphiques
# Tracer les 3 premiers graphiques des chaînes de Markov
plot(mcmc(resultat_chain[,1:3]))
mtext(expression("Graphiques pour " * alpha[0]), side = 3, line = 23)
mtext(expression("Graphiques pour " * alpha[1]), side = 3, line = 11.5)
mtext(expression("Graphiques pour " * alpha[12]), side = 3, line = 0.5)
par(mfrow = c(2, 1)) # Configure la disposition des graphiques
# Tracer les 2 derniers graphiques des chaînes de Markov
plot(mcmc(resultat_chain)[,4:5])
mtext(expression("Graphiques pour " * alpha[2]), side = 3, line = 12)
mtext(expression("Graphiques pour " * sigma), side = 3, line = 1)
library(coda)
par(ask = FALSE, mfrow = c(3, 1), mar = c(1, 1, 3, 3)) # Configure la disposition des graphiques
# Tracer les 3 premiers graphiques des chaînes de Markov
plot(mcmc(resultat_chain[,1:3]))
mtext(expression("Graphiques pour " * alpha[0]), side = 3, line = 23)
mtext(expression("Graphiques pour " * alpha[1]), side = 3, line = 11.5)
mtext(expression("Graphiques pour " * alpha[12]), side = 3, line = 0.5)
par(mfrow = c(2, 1)) # Configure la disposition des graphiques
# Tracer les 2 derniers graphiques des chaînes de Markov
plot(mcmc(resultat_chain)[,4:5])
mtext(expression("Graphiques pour " * alpha[2]), side = 3, line = 12)
mtext(expression("Graphiques pour " * sigma), side = 3, line = 1)
# Notations changées par rapport au fichier seeds.data pour être en accord avec
# la consigne donnée
"N" <- 21
"r" <- c(10, 23, 23, 26, 17, 5, 53, 55, 32, 46, 10, 8, 10, 8, 23, 0, 3, 22, 15, 32, 3)
"n" <- c(39, 62, 81, 51, 39, 6, 74, 72, 51, 79, 13, 16, 30, 28, 45, 4, 12, 41, 30, 51, 7)
"x1" <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
"x2" <- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
# mettre ce qui nous sert pour la suite
# Notations changées par rapport au fichier seeds.data pour être en accord avec
# la consigne donnée
"N" <- 21
"r" <- c(10, 23, 23, 26, 17, 5, 53, 55, 32, 46, 10, 8, 10, 8, 23, 0, 3, 22, 15, 32, 3)
"n" <- c(39, 62, 81, 51, 39, 6, 74, 72, 51, 79, 13, 16, 30, 28, 45, 4, 12, 41, 30, 51, 7)
"x1" <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
"x2" <- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
alpha0 <- 0
alpha1 <- 0
alpha2 <- 0
alpha12 <- 0
tau <- 10
b <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
seeds = function(nchain, N, r, n, x1, x2, alpha0, alpha1, alpha2, alpha12, tau, b, prop_sd){
# Initialisation
res = matrix(NA, nchain + 1, 5)
res[1, ] = c(alpha0, alpha1, alpha12, alpha2, 1/sqrt(tau)) # le dernier terme vaut sigma
p = plogis(alpha0 + alpha1 * x1 + alpha2 * x2 + alpha12 * x1 * x2 + b)
res_b = matrix(NA, nchain + 1, N)
res_b[1, ] = b
acc_rates = rep(0, 4) # pour les 4 alpha
for (i in 1:nchain){
# Mise à jour de alpha0
alpha0 = res[i, 1]
prop = rnorm(1, alpha0, prop_sd[1]) # marche aléatoire simple
prop_p = plogis(prop + alpha1 * x1 + alpha2 * x2 + alpha12 * x1 * x2 + b)
top = - ((prop^2) / (2 * 1e6)) + sum(r * log(prop_p)) + sum((n-r) * log(1 - prop_p))
bottom = - ((alpha0^2) / (2 * 1e6)) + sum(r * log(p)) + sum((n-r) * log(1 - p))
acc_prob = exp(top - bottom) # Ratio des noyaux vaut 1 (symétrie du noyau)
if (runif(1) < min(1, acc_prob)){
alpha0 = prop
p = prop_p
acc_rates[1] = acc_rates[1] + 1
}
# Mise à jour de alpha1
alpha1 = res[i, 2]
prop = rnorm(1, alpha1, prop_sd[2]) # marche aléatoire simple
prop_p = plogis(alpha0 + prop * x1 + alpha2 * x2 + alpha12 * x1 * x2 + b)
top = - ((prop^2) / (2 * 1e6)) + sum(r * log(prop_p)) + sum((n-r) * log(1 - prop_p))
bottom = - ((alpha1^2) / (2 * 1e6)) + sum(r * log(p)) + sum((n-r) * log(1 - p))
acc_prob = exp(top - bottom) # Ratio des noyaux vaut 1 (symétrie du noyau)
if (runif(1) < min(1, acc_prob)){
alpha1 = prop
p = prop_p
acc_rates[2] = acc_rates[2] + 1
}
# Mise à jour de alpha12
alpha12 = res[i, 3]
prop = rnorm(1, alpha12, prop_sd[3]) # marche aléatoire simple
prop_p = plogis(alpha0 + alpha1 * x1 + alpha2 * x2 + prop * x1 * x2 + b)
top = - ((prop^2) / (2 * 1e6)) + sum(r * log(prop_p)) + sum((n-r) * log(1 - prop_p))
bottom = - ((alpha12^2) / (2 * 1e6)) + sum(r * log(p)) + sum((n-r) * log(1 - p))
acc_prob = exp(top - bottom) # Ratio des noyaux vaut 1 (symétrie du noyau)
if (runif(1) < min(1, acc_prob)){
alpha12 = prop
p = prop_p
acc_rates[3] = acc_rates[3] + 1
}
# Mise à jour de alpha2
alpha2 = res[i, 4]
prop = rnorm(1, alpha2, prop_sd[4]) # marche aléatoire simple
prop_p = plogis(alpha0 + alpha1 * x1 + prop * x2 + alpha12 * x1 * x2 + b)
top = - ((prop^2) / (2 * 1e6)) + sum(r * log(prop_p)) + sum((n-r) * log(1 - prop_p))
bottom = - ((alpha2^2) / (2 * 1e6)) + sum(r * log(p)) + sum((n-r) * log(1 - p))
acc_prob = exp(top - bottom) # Ratio des noyaux vaut 1 (symétrie du noyau)
if (runif(1) < min(1, acc_prob)){
alpha2 = prop
p = prop_p
acc_rates[4] = acc_rates[4] + 1
}
# Mise à jour de tau
tau = rgamma(1, shape = 10e-3 + N / 2, scale = 1e-3 + 0.5 * sum(b^2))
# Mise à jour de b
for (j in 1:N){
prop = rnorm(1, b[j], prop_sd[5])
prop_p_j = plogis(alpha0 + alpha1 * x1[j] + alpha2 * x2[j] + alpha12 * x1[j] * x2[j] + prop)
top = - (prop^2 * tau / 2) + r[j] * log(prop_p_j) + (n[j] - r[j]) * log(1 - prop_p_j)
bottom = - (b[j]^2 * tau / 2) + r[j] * log(p[j]) + (n[j] - r[j]) * log(1 - p[j])
acc_prob = exp(top - bottom)
if (runif(1) < min(1, acc_prob)){
b[j] = prop
p[j] = prop_p_j
}
}
# Mise à jour de la chaine de Markov et de b
res[i+1, ] = c(alpha0, alpha1, alpha12, alpha2, 1/sqrt(tau))
res_b[i+1, ] = b
}
my_list <- list("chain" = res, "b_chain" = res_b, "acc_rates" = acc_rates)
return(my_list)
}
resultat = seeds(1e4, N, r, n, x1, x2, alpha0, alpha1, alpha2, alpha12, tau, b, prop_sd = c(0.3, 0.3, 0.3, 0.3, 0.3)) # prop_sd choisi pour avoir une allure de chaîne cohérente
resultat_chain = resultat$chain[1001:nrow(resultat$chain), ] # on enlève les 1000 premiers (burnin)
moychain = colMeans(resultat_chain) # moyenne
sdchain = apply(resultat_chain, 2, sd) # écart type
cat("alpha_0 est estimé à", moychain[1], "avec un écart-type de", sdchain[1], "\n")
cat("alpha_1 est estimé à", moychain[2], "avec un écart-type de", sdchain[2], "\n")
cat("alpha_12 est estimé à", moychain[3], "avec un écart-type de", sdchain[3], "\n")
cat("alpha_2 est estimé à", moychain[4], "avec un écart-type de", sdchain[4], "\n")
cat("sigma est estimé à", moychain[5], "avec un écart-type de", sdchain[5], "\n")
changement
# mettre ce qui nous sert pour la suite
# Notations changées par rapport au fichier seeds.data pour être en accord avec
# la consigne donnée
"N" <- 21
"r" <- c(10, 23, 23, 26, 17, 5, 53, 55, 32, 46, 10, 8, 10, 8, 23, 0, 3, 22, 15, 32, 3)
"n" <- c(39, 62, 81, 51, 39, 6, 74, 72, 51, 79, 13, 16, 30, 28, 45, 4, 12, 41, 30, 51, 7)
"x1" <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
"x2" <- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
alpha0 <- 0
alpha1 <- 0
alpha2 <- 0
alpha12 <- 0
tau <- 10
b <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
seeds = function(nchain, N, r, n, x1, x2, alpha0, alpha1, alpha2, alpha12, tau, b, prop_sd){
# Initialisation
res = matrix(NA, nchain + 1, 5)
res[1, ] = c(alpha0, alpha1, alpha12, alpha2, 1/sqrt(tau)) # le dernier terme vaut sigma
p = plogis(alpha0 + alpha1 * x1 + alpha2 * x2 + alpha12 * x1 * x2 + b)
res_b = matrix(NA, nchain + 1, N)
res_b[1, ] = b
acc_rates = rep(0, 4) # pour les 4 alpha
for (i in 1:nchain){
# Mise à jour de alpha0
alpha0 = res[i, 1]
prop = rnorm(1, alpha0, prop_sd[1]) # marche aléatoire simple
prop_p = plogis(prop + alpha1 * x1 + alpha2 * x2 + alpha12 * x1 * x2 + b)
top = - ((prop^2) / (2 * 1e6)) + sum(r * log(prop_p)) + sum((n-r) * log(1 - prop_p))
bottom = - ((alpha0^2) / (2 * 1e6)) + sum(r * log(p)) + sum((n-r) * log(1 - p))
acc_prob = exp(top - bottom) # Ratio des noyaux vaut 1 (symétrie du noyau)
if (runif(1) < min(1, acc_prob)){
alpha0 = prop
p = prop_p
acc_rates[1] = acc_rates[1] + 1
}
# Mise à jour de alpha1
alpha1 = res[i, 2]
prop = rnorm(1, alpha1, prop_sd[2]) # marche aléatoire simple
prop_p = plogis(alpha0 + prop * x1 + alpha2 * x2 + alpha12 * x1 * x2 + b)
top = - ((prop^2) / (2 * 1e6)) + sum(r * log(prop_p)) + sum((n-r) * log(1 - prop_p))
bottom = - ((alpha1^2) / (2 * 1e6)) + sum(r * log(p)) + sum((n-r) * log(1 - p))
acc_prob = exp(top - bottom) # Ratio des noyaux vaut 1 (symétrie du noyau)
if (runif(1) < min(1, acc_prob)){
alpha1 = prop
p = prop_p
acc_rates[2] = acc_rates[2] + 1
}
# Mise à jour de alpha12
alpha12 = res[i, 3]
prop = rnorm(1, alpha12, prop_sd[3]) # marche aléatoire simple
prop_p = plogis(alpha0 + alpha1 * x1 + alpha2 * x2 + prop * x1 * x2 + b)
top = - ((prop^2) / (2 * 1e6)) + sum(r * log(prop_p)) + sum((n-r) * log(1 - prop_p))
bottom = - ((alpha12^2) / (2 * 1e6)) + sum(r * log(p)) + sum((n-r) * log(1 - p))
acc_prob = exp(top - bottom) # Ratio des noyaux vaut 1 (symétrie du noyau)
if (runif(1) < min(1, acc_prob)){
alpha12 = prop
p = prop_p
acc_rates[3] = acc_rates[3] + 1
}
# Mise à jour de alpha2
alpha2 = res[i, 4]
prop = rnorm(1, alpha2, prop_sd[4]) # marche aléatoire simple
prop_p = plogis(alpha0 + alpha1 * x1 + prop * x2 + alpha12 * x1 * x2 + b)
top = - ((prop^2) / (2 * 1e6)) + sum(r * log(prop_p)) + sum((n-r) * log(1 - prop_p))
bottom = - ((alpha2^2) / (2 * 1e6)) + sum(r * log(p)) + sum((n-r) * log(1 - p))
acc_prob = exp(top - bottom) # Ratio des noyaux vaut 1 (symétrie du noyau)
if (runif(1) < min(1, acc_prob)){
alpha2 = prop
p = prop_p
acc_rates[4] = acc_rates[4] + 1
}
# Mise à jour de tau
tau = rgamma(1, shape = 10e-3 + N / 2, scale = 1e-3 + 0.5 * sum(b^2))
# Mise à jour de b
for (j in 1:N){
prop = rnorm(1, b[j], prop_sd[5])
prop_p_j = plogis(alpha0 + alpha1 * x1[j] + alpha2 * x2[j] + alpha12 * x1[j] * x2[j] + prop)
top = - (prop^2 * tau / 2) + r[j] * log(prop_p_j) + (n[j] - r[j]) * log(1 - prop_p_j)
bottom = - (b[j]^2 * tau / 2) + r[j] * log(p[j]) + (n[j] - r[j]) * log(1 - p[j])
acc_prob = exp(top - bottom)
if (runif(1) < min(1, acc_prob)){
b[j] = prop
p[j] = prop_p_j
}
}
# Mise à jour de la chaine de Markov et de b
res[i+1, ] = c(alpha0, alpha1, alpha12, alpha2, 1/sqrt(tau))
res_b[i+1, ] = b
}
my_list <- list("chain" = res, "b_chain" = res_b, "acc_rates" = acc_rates)
return(my_list)
}
resultat = seeds(1e4, N, r, n, x1, x2, alpha0, alpha1, alpha2, alpha12, tau, b, prop_sd = c(0.3, 0.3, 0.3, 0.3, 0.3)) # prop_sd choisi pour avoir une allure de chaîne cohérente
resultat_chain = resultat$chain[1001:nrow(resultat$chain), ] # on enlève les 1000 premiers (burnin)
moychain = colMeans(resultat_chain) # moyenne
sdchain = apply(resultat_chain, 2, sd) # écart type
cat("alpha_0 est estimé à", moychain[1], "avec un écart-type de", sdchain[1], "\n")
cat("alpha_1 est estimé à", moychain[2], "avec un écart-type de", sdchain[2], "\n")
cat("alpha_12 est estimé à", moychain[3], "avec un écart-type de", sdchain[3], "\n")
cat("alpha_2 est estimé à", moychain[4], "avec un écart-type de", sdchain[4], "\n")
cat("sigma est estimé à", moychain[5], "avec un écart-type de", sdchain[5], "\n")
library(coda)
par(ask = FALSE, mfrow = c(3, 1), mar = c(1, 1, 3, 3)) # Configure la disposition des graphiques
# Tracer les 3 premiers graphiques des chaînes de Markov
plot(mcmc(resultat_chain[,1:3]))
mtext(expression("Graphiques pour " * alpha[0]), side = 3, line = 23)
mtext(expression("Graphiques pour " * alpha[1]), side = 3, line = 11.5)
mtext(expression("Graphiques pour " * alpha[12]), side = 3, line = 0.5)
par(mfrow = c(2, 1)) # Configure la disposition des graphiques
# Tracer les 2 derniers graphiques des chaînes de Markov
plot(mcmc(resultat_chain)[,4:5])
mtext(expression("Graphiques pour " * alpha[2]), side = 3, line = 12)
mtext(expression("Graphiques pour " * sigma), side = 3, line = 1)
cat("logit(p) : ", "\n")
cat("pour x1 = 0 et x2 = 0:", moychain[1] + moychain[2]*0 + moychain[3]*0 + moychain[4]*0 + 0, "\n")
cat("pour x1 = 0 et x2 = 1:", moychain[1] + moychain[2]*0 + moychain[3]*1 + moychain[4]*0 + 0, "\n")
cat("pour x1 = 1 et x2 = 0:", moychain[1] + moychain[2]*1 + moychain[3]*0 + moychain[4]*0 + 0, "\n")
cat("pour x1 = 1 et x2 = 1:", moychain[1] + moychain[2]*1 + moychain[3]*1 + moychain[4]*0 + 0, "\n")
resultat_b_chain = resultat$b_chain[1001:nrow(resultat$b_chain), ] # on enlève les 1000 premiers (burnin)
moyb_chain = colMeans(resultat_b_chain) # moyenne
moyb_chain
moyb_chain[1:5]
cat("logit(p) : ", "\n")
cat("pour x1 = 0 et x2 = 0:", moychain[1] + moychain[2]*0 + moychain[3]*0 + moychain[4]*0 + mean(moyb_chain[1:5]), "\n")
cat("pour x1 = 0 et x2 = 1:", moychain[1] + moychain[2]*0 + moychain[3]*1 + moychain[4]*0 + mean(moyb_chain[6:11]), "\n")
cat("pour x1 = 1 et x2 = 0:", moychain[1] + moychain[2]*1 + moychain[3]*0 + moychain[4]*0 + mean(moyb_chain[12:16]), "\n")
cat("pour x1 = 1 et x2 = 1:", moychain[1] + moychain[2]*1 + moychain[3]*1 + moychain[4]*0 + mean(moyb_chain[17:21]), "\n")
# mettre ce qui nous sert pour la suite
"N" <- 21
"r" <- c(10, 23, 23, 26, 17, 5, 53, 55, 32, 46, 10, 8, 10, 8, 23, 0, 3, 22, 15, 32, 3)
"n" <- c(39, 62, 81, 51, 39, 6, 74, 72, 51, 79, 13, 16, 30, 28, 45,  4, 12, 41, 30, 51, 7)
"x1" <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
"x2" <- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
init_alpha0 <- 0
init_alpha1 <- 0
init_alpha2 <- 0
init_alpha12 <- 0
init_sigma <- 1/10
init_b <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
library(boot)
library(coda)
library(factoextra)
seeds <- function(nchain, init_alpha0, init_alpha1, init_alpha2, init_alpha12, init_sigma, init_b, prop_sd, x1, x2, N)
{
alpha0 <- init_alpha0
alpha1 <- init_alpha1
alpha2 <- init_alpha2
alpha12 <- init_alpha12
sigma <- init_sigma
b <- init_b
p <- plogis(alpha0 + alpha1 * x1 + alpha2 * x2 + alpha12 * x1 * x2 + b)
chain <- matrix(NA, nchain + 1, 5)
chain_b <- matrix(NA, nchain + 1, N)
chain[1,1] <- init_alpha0
chain[1,2] <- init_alpha1
chain[1,3] <- init_alpha2
chain[1,4] <- init_alpha12
chain[1,5] <- init_sigma
chain_b[1,] <- init_b
acc_rates <- rep(0,4)
for (i in 1:nchain)
{
# Mise à jour de alpha0
prop <- rnorm(1, alpha0, prop_sd[1])
prop_p <- plogis(prop + alpha1 * x1 + alpha2 * x2 + alpha12 * x1 * x2 + b)
top <- - ((prop^2) / (2 * 1e6)) + sum(r * log(prop_p)) + sum((n-r) * log(1 - prop_p))
bottom <- - ((alpha0^2) / (2 * 1e6)) + sum(r * log(p)) + sum((n-r) * log(1 - p))
acc_prob <- exp(top - bottom)
if (runif(1) < acc_prob){
alpha0 <- prop
p <- prop_p
acc_rates[1] <- acc_rates[1]+1
}
# Mise à jour de alpha1
prop <- rnorm(1, alpha1, prop_sd[2])
prop_p <- plogis(alpha0 + prop * x1 + alpha2 * x2 + alpha12 * x1 * x2 + b)
top <- - ((prop^2) / (2 * 1e6)) + sum(r * log(prop_p)) + sum((n-r) * log(1 - prop_p))
bottom <- - ((alpha1^2) / (2 * 1e6)) + sum(r * log(p)) + sum((n-r) * log(1 - p))
acc_prob <- exp(top - bottom)
if (runif(1) < acc_prob){
alpha1 <- prop
p <- prop_p
acc_rates[2] <- acc_rates[2]+1
}
# Mise à jour de alpha2
prop <- rnorm(1, alpha2, prop_sd[3])
prop_p <- plogis(alpha0 + alpha1 * x1 + prop * x2 + alpha12 * x1 * x2 + b)
top <- - ((prop^2) / (2 * 1e6)) + sum(r * log(prop_p)) + sum((n-r) * log(1 - prop_p))
bottom <- - ((alpha2^2) / (2 * 1e6)) + sum(r * log(p)) + sum((n-r) * log(1 - p))
acc_prob <- exp(top - bottom)
if (runif(1) < acc_prob){
alpha2 <- prop
p <- prop_p
acc_rates[3] <- acc_rates[3]+1
}
# Mise à jour de alpha12
prop <- rnorm(1, alpha12, prop_sd[4])
prop_p <- plogis(alpha0 + alpha1 * x1 + alpha2 * x2 + prop * x1 * x2 + b)
top <- - ((prop^2) / (2 * 1e6)) + sum(r * log(prop_p)) + sum((n-r) * log(1 - prop_p))
bottom <- - ((alpha12^2) / (2 * 1e6)) + sum(r * log(p)) + sum((n-r) * log(1 - p))
acc_prob <- exp(top - bottom)
if (runif(1) < acc_prob){
alpha12 <- prop
p <- prop_p
acc_rates[4] <- acc_rates[4]+1
}
# Mise à jour de sigma
sigma <- 1 / rgamma(1, shape = 10e-3 + N / 2, scale = 1e-3 + 0.5 * sum(b^2)) #change parameters
# Mise à jour de b
for (j in 1:N)
{
prop <- rnorm(1, b[j], prop_sd[5])
prop_p_j <- plogis(alpha0 + alpha1 * x1[j] + alpha2 * x2[j] + alpha12 * x1[j] * x2[j] + prop)
top <- - (prop^2 / (2 * sigma)) + r[j] * log(prop_p_j) + (n[j] - r[j]) * log(1 - prop_p_j)
bottom <- - (b[j]^2 / (2 * sigma)) + r[j] * log(p[j]) + (n[j] - r[j]) * log(1 - p[j])
acc_prob <- exp(top - bottom)
if (runif(1) < acc_prob){
b[j] <- prop
p[j] <- prop_p_j
}
}
#Mise à jour de la chaine
chain[i+1,] <- c(alpha0, alpha1, alpha2, alpha12, sigma)
chain_b[i+1,] <- b
}
my_list <- list("chain" = chain, "b_chain" = chain_b, "acc_rates" = acc_rates)
return(my_list)
}
l <- seeds(1e4, init_alpha0, init_alpha1, init_alpha2, init_alpha12, init_sigma, init_b, prop_sd = c(0.25, 0.5, 0.3, 0.5, 0.3), x1, x2, N)
burnin <- (1:1000)
plot(l$chain[-burnin,][,1], type = "l", main = "")
plot(density(l$chain[-burnin,][,1]), type = "l", main = "densité de alpha0")
sprintf("Le taux d'acceptation de alpha0 : %s", l$acc_rates[1]/100)
mean_alpha0 = mean(l$chain[,1])
sprintf("La moyenne empirique de alpha0 : %s", mean_alpha0)
sd_alpha0 = sd(l$chain[,1])
sprintf("L'écart-type empirique de alpha0 : %s", sd_alpha0)
plot(l$chain[-burnin,][,2], type = "l", main = "")
plot(density(l$chain[-burnin,][,2]), type = "l", main = "densité de alpha1")
sprintf("Le taux d'acceptation de alpha1 : %s", l$acc_rates[2]/100)
mean_alpha1 = mean(l$chain[,2])
sprintf("La moyenne empirique de alpha1 : %s", mean_alpha1)
sd_alpha1 = sd(l$chain[,2])
sprintf("L'écart-type empirique de alpha1 : %s", sd_alpha1)
plot(l$chain[-burnin,][,3], type = "l", main = "")
plot(density(l$chain[-burnin,][,3]), type = "l", main = "densité de alpha2")
sprintf("Le taux d'acceptation de alpha2 : %s", l$acc_rates[3]/100)
mean_alpha2 = mean(l$chain[,3])
sprintf("La moyenne empirique de alpha2 : %s", mean_alpha2)
sd_alpha2 = sd(l$chain[,3])
sprintf("L'écart-type empirique de alpha2 : %s", sd_alpha2)
plot(l$chain[-burnin,][,4], type = "l", main = "")
plot(density(l$chain[-burnin,][,4]), type = "l", main = "densité de alpha12")
sprintf("Le taux d'acceptation de alpha12 : %s", l$acc_rates[4]/100)
mean_alpha12 = mean(l$chain[,4])
sprintf("La moyenne empirique de alpha12 : %s", mean_alpha12)
sd_alpha12 = sd(l$chain[,4])
sprintf("L'écart-type empirique de alpha12 : %s", sd_alpha12)
plot(l$chain[-burnin,][,5], type = "l", main = "")
plot(density(l$chain[-burnin,][,5]), type = "l", main = "densité de sigma")
mean_sigma = mean(sqrt(l$chain[,5]))
sprintf("La moyenne empirique de sigma : %s", mean_sigma)
sd_sigma = sd(sqrt(l$chain[,5]))
sprintf("L'écart-type empirique de sigma : %s", sd_sigma)
text=c("alpha0", "alpha1", "alpha2", "alpha12", "sigma")
par(mfrow = c(5, 2), mar = c(1, 6, 1, 6))
for (j in 1:5){
plot(l$chain[-burnin,][,j], type = "l", main = "",ylab=text[j])
plot(density(l$chain[-burnin,][,j]), type = "l", main = "")
}
text=c("b1", "b5", "b10", "b15")
val = c(1,5,10,15)
par(mfrow = c(4, 2), mar = c(1, 6, 1, 6))
for (j in 1:4){
plot(l$b_chain[-burnin,][,val[j]], type = "l", main = "",ylab=text[j])
plot(density(l$b_chain[-burnin,][,val[j]]), type = "l", main = "")
}
mean_b = c(mean(l$b_chain[,1]))
for (i in 2:21){
mean_b <- append(mean_b, mean(l$b_chain[,i]))
}
logitp = mean_alpha0 + mean_alpha1 * x1 + mean_alpha2 * x2 + mean_alpha12 * x1 * x2 + mean_b
plot(logitp)
index <- 1:21
df <- data.frame(index, logitp)
res_kmeans <- kmeans(df, centers = 4 , nstart = 1000)
fviz_cluster(res_kmeans, data = df)
c1 = which(res_kmeans$cluster==1)
c2 = which(res_kmeans$cluster==2)
c3 = which(res_kmeans$cluster==3)
c4 = which(res_kmeans$cluster==4)
x <- x1*x2
x[c1]
x[c2]
x[c3]
x[c4]
x1[c1]
x1[c2]
x1[c3]
x1[c4]
x2[c1]
x2[c2]
x2[c3]
x2[c4]
text=c("b1", "b5", "b10", "b15")
val = c(1,5,10,15)
par(mfrow = c(4, 2), mar = c(1, 6, 1, 6))
for (j in 1:4){
plot(l$b_chain[-burnin,][,val[j]], type = "l", main = "",ylab=text[j])
plot(density(l$b_chain[-burnin,][,val[j]]), type = "l", main = "")
}
text=c("b1", "b5", "b10", "b15")
val = c(1,5,10,15)
par(mfrow = c(4, 2), mar = c(1, 6, 1, 6))
for (j in 1:4){
plot(resultat$b_chain[-burnin,][,val[j]], type = "l", main = "",ylab=text[j])
plot(density(resultat$b_chain[-burnin,][,val[j]]), type = "l", main = "")
}
legend=c("b1", "b7", "b14", "b21")
valeur = c(1,7,14,21)
par(mfrow = c(4, 2), mar = c(1, 6, 1, 6))
for (j in 1:4){
plot(resultat$b_chain[-burnin,][,valeur[j]], type = "l", main = "",ylab=legend[j])
plot(density(resultat$b_chain[-burnin,][,valeur[j]]), type = "l", main = "")
}
#pour les alpha, on utilise les moyennes calculé précèment. Pour b, on fait en plus la moyenne sur les plaques qui ont les mêmes types de graines.
cat("logit(p) : ", "\n")
cat("pour x1 = 0 et x2 = 0:", moychain[1] + moychain[2]*0 + moychain[3]*0 + moychain[4]*0 + mean(moyb_chain[1:5]), "\n")
cat("pour x1 = 0 et x2 = 1:", moychain[1] + moychain[2]*0 + moychain[3]*0 + moychain[4]*1 + mean(moyb_chain[6:11]), "\n")
cat("pour x1 = 1 et x2 = 0:", moychain[1] + moychain[2]*1 + moychain[3]*0 + moychain[4]*0 + mean(moyb_chain[12:16]), "\n")
cat("pour x1 = 1 et x2 = 1:", moychain[1] + moychain[2]*1 + moychain[3]*1 + moychain[4]*1+ mean(moyb_chain[17:21]), "\n")
